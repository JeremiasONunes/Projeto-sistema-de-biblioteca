# PLANO DE TRABALHO DOCENTE 

## MODELO PEDAGÃ“GICO SENAC 

**Curso:** TÃ©cnico em Desenvolvimento de Sistemas  
**Carga HorÃ¡ria Total:** 36 horas  
**Carga HorÃ¡ria da UC:** 36 horas  

**Docente:** Jeremias O Nunes  

---

## PLANO DE AULA â€“ HeranÃ§a: Criando Hierarquias de Classes

ğŸ“Œ **Disciplina:** Desenvolver programas orientados a objetos em linguagem Java  
ğŸ‘¨ğŸ« **Mentor(a):** Jeremias O Nunes  
ğŸ“† **Data:** Aula nÂº 03  
â° **DuraÃ§Ã£o:** 3 horas (180 minutos)  

---

## ğŸ“– Planejamento

### ğŸ“Œ ConteÃºdo Formativo
- Conceitos de heranÃ§a: superclasse, subclasse, hierarquia  
- Classes abstratas vs classes concretas  
- Palavras-chave super() e this(): uso e diferenÃ§as  
- EspecializaÃ§Ã£o de classes no contexto do projeto  
- ImplementaÃ§Ã£o de hierarquias para Livro e Usuario  

### ğŸ¯ Objetivo Geral
Implementar heranÃ§a criando especializaÃ§Ãµes das classes base do sistema de biblioteca.

### ğŸ’¡ Habilidades e CompetÃªncias
âœ… Aplicar conceitos de heranÃ§a na prÃ¡tica  
âœ… Criar hierarquias de classes bem estruturadas  
âœ… Utilizar adequadamente super() e this()  
âœ… Implementar classes abstratas quando apropriado  

### ğŸ“Œ Materiais NecessÃ¡rios
ğŸ“Œ Classes Livro e Usuario da aula anterior  
ğŸ“Œ Diagramas UML para visualizaÃ§Ã£o de hierarquias  
ğŸ“Œ IDE configurada com projeto biblioteca  

---

## ğŸ“ EstratÃ©gias de Ensino e Aprendizagem

### IntroduÃ§Ã£o e ContextualizaÃ§Ã£o (15min)
**Metodologia Ativa - Brainstorming:**  
DiscussÃ£o sobre diferentes tipos de livros e usuÃ¡rios em uma biblioteca real, identificando caracterÃ­sticas comuns e especÃ­ficas.

---

### **TÃ³pico 1: Fundamentos de HeranÃ§a (54min - Teoria)**
#### ğŸ“Œ DemonstraÃ§Ã£o PrÃ¡tica:
**Metodologia Ativa - Aula Expositiva Dialogada:**  
â€¢ Conceitos de heranÃ§a: superclasse, subclasse, hierarquia  
â€¢ Classes abstratas vs classes concretas: quando usar cada uma  
â€¢ Palavras-chave super() e this(): uso correto e diferenÃ§as  
â€¢ Vantagens e desvantagens da heranÃ§a  

#### ğŸ“Œ Atividade PrÃ¡tica 1:
ğŸ¯ **Objetivo:** Analisar requisitos para especializaÃ§Ã£o  
ğŸ“ **Tarefa:**  
- **Metodologia Ativa - AnÃ¡lise de Casos:**  
IdentificaÃ§Ã£o de atributos e comportamentos especÃ­ficos para diferentes tipos de livros

**Parte do Projeto ConstruÃ­da:** AnÃ¡lise de requisitos documentada

---

### **TÃ³pico 2: Especializando a Classe Livro (45min)**
#### ğŸ“Œ DemonstraÃ§Ã£o PrÃ¡tica:
**Metodologia Ativa - Live Coding:**  
CriaÃ§Ã£o das subclasses LivroImpresso e Ebook, demonstrando heranÃ§a na prÃ¡tica

#### ğŸ“Œ Atividade PrÃ¡tica 2:
ğŸ¯ **Objetivo:** Implementar hierarquia de livros  
ğŸ“ **Tarefa:**  
- **Metodologia Ativa - ProgramaÃ§Ã£o Guiada:**  
CriaÃ§Ã£o das classes LivroImpresso (com numeroPaginas) e Ebook (com tamanhoMB)

**Parte do Projeto ConstruÃ­da:** Hierarquia de classes Livro implementada

---

### **TÃ³pico 3: Classe Abstrata Usuario (45min)**
#### ğŸ“Œ DemonstraÃ§Ã£o PrÃ¡tica:
**Metodologia Ativa - Modelagem Colaborativa:**  
TransformaÃ§Ã£o da classe Usuario em classe abstrata e anÃ¡lise dos benefÃ­cios

#### ğŸ“Œ Atividade PrÃ¡tica 3:
ğŸ¯ **Objetivo:** Implementar classe abstrata Usuario  
ğŸ“ **Tarefa:**  
- **Metodologia Ativa - RefatoraÃ§Ã£o Guiada:**  
ConversÃ£o da classe Usuario para abstrata com mÃ©todos comuns

**Parte do Projeto ConstruÃ­da:** Classe abstrata Usuario implementada

---

### **TÃ³pico 4: Uso de super() e this() (30min)**
#### ğŸ“Œ DemonstraÃ§Ã£o PrÃ¡tica:
**Metodologia Ativa - DemonstraÃ§Ã£o Interativa:**  
ImplementaÃ§Ã£o prÃ¡tica de construtores usando super() e this() nas subclasses

#### ğŸ“Œ Atividade PrÃ¡tica 4:
ğŸ¯ **Objetivo:** Dominar o uso de super() e this()  
ğŸ“ **Tarefa:**  
- **Metodologia Ativa - ExercÃ­cios PrÃ¡ticos:**  
ImplementaÃ§Ã£o de construtores nas subclasses com chamadas adequadas

**Parte do Projeto ConstruÃ­da:** Construtores otimizados com super() e this()

---

### Encerramento e ReflexÃ£o (15min)
#### ğŸ“Œ DiscussÃ£o em grupo:
**Metodologia Ativa - Peer Review:**  
AnÃ¡lise das hierarquias criadas e discussÃ£o sobre design de classes

#### ğŸ“Œ Desafio para a prÃ³xima aula:
**Metodologia Ativa - Desafio Conceitual:**  
Pensar em como diferentes tipos de usuÃ¡rios podem ter comportamentos distintos

---

### ğŸ“Œ Objetos de Aprendizagem
ğŸ“ **Materiais DidÃ¡ticos Utilizados:**  
- Diagramas UML de hierarquia de classes  
- CÃ³digo das subclasses implementadas  
- Exemplos de uso de super() e this()  

---

## ğŸ¯ AvaliaÃ§Ã£o

### **AvaliaÃ§Ã£o Formativa (Durante a aula):**
âœ… CompreensÃ£o dos conceitos de heranÃ§a  
âœ… Qualidade da modelagem das hierarquias  
âœ… Uso correto de super() e this()  
âœ… ParticipaÃ§Ã£o ativa nas discussÃµes de design  

### **AvaliaÃ§Ã£o Somativa (EntregÃ¡veis):**
âœ… Subclasses LivroImpresso e Ebook funcionais  
âœ… Classe abstrata Usuario implementada corretamente  
âœ… Construtores com uso adequado de super() e this()  

### **CritÃ©rios de Qualidade:**
- **Excelente (9-10):** Hierarquias bem estruturadas, uso correto de heranÃ§a e cÃ³digo limpo  
- **Bom (7-8):** ImplementaÃ§Ã£o funcional com pequenos ajustes de design  
- **SatisfatÃ³rio (6-7):** Conceitos aplicados com orientaÃ§Ã£o, funcionalidades bÃ¡sicas  
- **InsatisfatÃ³rio (<6):** Dificuldades na compreensÃ£o ou implementaÃ§Ã£o de heranÃ§a  

---

## ğŸ“ ConclusÃ£o

### **Aprendizado Esperado:**
ğŸ¯ **Conhecimento TÃ©cnico:**  
- DomÃ­nio completo dos conceitos de heranÃ§a  
- CompreensÃ£o de classes abstratas  
- Uso eficiente de super() e this()  

ğŸ¯ **AplicaÃ§Ã£o PrÃ¡tica:**  
- Hierarquias de classes bem estruturadas  
- EspecializaÃ§Ã£o adequada de comportamentos  
- CÃ³digo reutilizÃ¡vel e manutenÃ­vel  

ğŸ¯ **CompetÃªncias Profissionais:**  
- Pensamento orientado a objetos  
- Design de software estruturado  
- AnÃ¡lise de requisitos para modelagem  

### **ConexÃ£o com o Projeto:**  
Esta aula introduz a especializaÃ§Ã£o no Sistema de Biblioteca, criando diferentes tipos de livros que mantÃªm caracterÃ­sticas comuns mas possuem atributos especÃ­ficos.

### **PreparaÃ§Ã£o para PrÃ³xima Aula:**  
As hierarquias criadas estarÃ£o prontas para demonstrar polimorfismo, onde objetos de diferentes tipos poderÃ£o ser tratados de forma uniforme atravÃ©s de suas interfaces comuns.